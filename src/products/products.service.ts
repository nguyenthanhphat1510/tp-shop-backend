import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { MongoRepository } from 'typeorm';
import { ObjectId } from 'mongodb';
import { Product } from './entities/product.entity';
import { ProductVariant } from './entities/product-variant.entity';
import { CreateProductWithVariantsDto } from './dto/create-product-with-variants.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { Category } from '../category/entities/category.entity';
import { Subcategory } from '../subcategory/entities/subcategory.entity';
import { CloudinaryService } from '../cloudinary/cloudinary.service';
import { GeminiService } from '../gemini/gemini.service'; // ‚úÖ TH√äM

@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private productsRepository: MongoRepository<Product>,
    @InjectRepository(ProductVariant)
    private variantsRepository: MongoRepository<ProductVariant>,
    @InjectRepository(Category)
    private categoryRepository: MongoRepository<Category>,
    @InjectRepository(Subcategory)
    private subcategoryRepository: MongoRepository<Subcategory>,
    private cloudinaryService: CloudinaryService,
    private geminiService: GeminiService, // ‚úÖ TH√äM
  ) { }

  /**
   * üÜï T·∫†O S·∫¢N PH·∫®M V·ªöI VARIANTS
   * 
   * H√†m n√†y t·∫°o m·ªôt s·∫£n ph·∫©m m·ªõi v·ªõi nhi·ªÅu bi·∫øn th·ªÉ (variants).
   * M·ªói variant c√≥ dung l∆∞·ª£ng, m√†u s·∫Øc, gi√° v√† ·∫£nh ri√™ng bi·ªát.
   * 
   * @param createProductDto - D·ªØ li·ªáu s·∫£n ph·∫©m v√† variants
   * @param files - File ·∫£nh cho t·ª´ng variant (optional)
   * @returns Promise<{ product: Product; variants: ProductVariant[] }>
   */
  async createWithVariants(
    createProductDto: CreateProductWithVariantsDto,
    files?: { [fieldname: string]: Express.Multer.File[] }
  ): Promise<{ product: Product; variants: ProductVariant[] }> {
    try {
      console.log('üÜï B·∫Øt ƒë·∫ßu t·∫°o s·∫£n ph·∫©m v·ªõi variants:', createProductDto);

      // üìç B∆Ø·ªöC 1: VALIDATE CATEGORY V√Ä SUBCATEGORY
      // Chuy·ªÉn ƒë·ªïi string ID th√†nh ObjectId ƒë·ªÉ query MongoDB
      const categoryObjectId = new ObjectId(createProductDto.categoryId);
      const subcategoryObjectId = new ObjectId(createProductDto.subcategoryId);

      // Ki·ªÉm tra ƒë·ªìng th·ªùi category v√† subcategory c√≥ t·ªìn t·∫°i kh√¥ng
      const [category, subcategory] = await Promise.all([
        this.categoryRepository.findOne({ where: { _id: categoryObjectId } }),
        this.subcategoryRepository.findOne({ where: { _id: subcategoryObjectId } })
      ]);

      // N√©m l·ªói n·∫øu kh√¥ng t√¨m th·∫•y category
      if (!category) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y danh m·ª•c v·ªõi ID ${createProductDto.categoryId}`);
      }

      // N√©m l·ªói n·∫øu kh√¥ng t√¨m th·∫•y subcategory
      if (!subcategory) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y danh m·ª•c con v·ªõi ID ${createProductDto.subcategoryId}`);
      }

      // Ki·ªÉm tra subcategory c√≥ thu·ªôc v·ªÅ category ƒë√£ ch·ªçn kh√¥ng
      if (subcategory.categoryId.toString() !== categoryObjectId.toString()) {
        throw new BadRequestException('‚ùå Danh m·ª•c con kh√¥ng thu·ªôc danh m·ª•c ƒë√£ ch·ªçn');
      }

      console.log('‚úÖ Category v√† Subcategory h·ª£p l·ªá');

      // üìç B∆Ø·ªöC 2: KI·ªÇM TRA T√äN S·∫¢N PH·∫®M ƒê√É T·ªíN T·∫†I
      // T√¨m s·∫£n ph·∫©m c√≥ t√™n tr√πng trong database
      const existingProduct = await this.productsRepository.findOne({
        where: { name: createProductDto.name }
      });

      // N√©m l·ªói n·∫øu t√™n ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng
      if (existingProduct) {
        throw new BadRequestException(`‚ùå S·∫£n ph·∫©m v·ªõi t√™n "${createProductDto.name}" ƒë√£ t·ªìn t·∫°i`);
      }

      console.log('‚úÖ T√™n s·∫£n ph·∫©m ch∆∞a ƒë∆∞·ª£c s·ª≠ d·ª•ng');

      // üìç B∆Ø·ªöC 3: T·∫†O S·∫¢N PH·∫®M CH√çNH (CH·ªà TH√îNG TIN C∆† B·∫¢N)
      /*
       * S·∫£n ph·∫©m ch√≠nh ch·ªâ ch·ª©a th√¥ng tin m√¥ t·∫£, kh√¥ng c√≥:
       * - Gi√° c·ª• th·ªÉ (price) - v√¨ m·ªói variant c√≥ gi√° kh√°c nhau
       * - S·ªë l∆∞·ª£ng (stock) - v√¨ m·ªói variant c√≥ stock ri√™ng
       * - ·∫¢nh (imageUrls) - v√¨ m·ªói variant c√≥ ·∫£nh theo m√†u s·∫Øc
       */
      const productData = {
        name: createProductDto.name,           // T√™n s·∫£n ph·∫©m: "iPhone 16"
        description: createProductDto.description, // M√¥ t·∫£ chi ti·∫øt
        categoryId: categoryObjectId,         // ID danh m·ª•c cha
        subcategoryId: subcategoryObjectId,   // ID danh m·ª•c con
        isActive: true                        // Tr·∫°ng th√°i ho·∫°t ƒë·ªông
        // ‚ùå KH√îNG c√≥: price, stock, imageUrls, brand
      };

      // T·∫°o instance v√† l∆∞u v√†o database
      const newProduct = this.productsRepository.create(productData);

      // ‚ùå COMMENT PH·∫¶N T·∫†O VECTOR (V√å QUOTA GEMINI H·∫æT)
      // console.log('üß† ƒêang t·∫°o vector cho s·∫£n ph·∫©m...');
      // T·∫°o text ƒë·ªÉ search
      // newProduct.searchText = newProduct.createSearchText();
      // console.log(`üìù Text ƒë·ªÉ t·∫°o vector: "${newProduct.searchText}"`);

      // T·∫°o vector t·ª´ text
      // newProduct.embedding = await this.geminiService.createEmbedding(newProduct.searchText);
      // console.log(`‚úÖ T·∫°o ƒë∆∞·ª£c vector c√≥ ${newProduct.embedding.length} chi·ªÅu`);

      const savedProduct = await this.productsRepository.save(newProduct);

      console.log(`‚úÖ ƒê√£ t·∫°o s·∫£n ph·∫©m ch√≠nh: "${savedProduct.name}" v·ªõi ID: ${savedProduct._id}`);

      // üìç B∆Ø·ªöC 4: T·∫†O T·∫§T C·∫¢ VARIANTS
      /*
       * M·ªói variant ƒë·∫°i di·ªán cho m·ªôt phi√™n b·∫£n c·ª• th·ªÉ c·ªßa s·∫£n ph·∫©m:
       * - iPhone 16 128GB ƒêen: gi√° 22 tri·ªáu, stock 50
       * - iPhone 16 256GB Tr·∫Øng: gi√° 25 tri·ªáu, stock 30
       * - iPhone 16 512GB Xanh: gi√° 28 tri·ªáu, stock 20
       */

      const createdVariants: ProductVariant[] = [];

      // Duy·ªát qua t·ª´ng variant trong danh s√°ch
      for (let i = 0; i < createProductDto.variants.length; i++) {
        const variantDto = createProductDto.variants[i];

        console.log(`üîÑ ƒêang t·∫°o variant ${i + 1}/${createProductDto.variants.length}:`, variantDto);

        // ‚úÖ VALIDATE VARIANT DATA TR∆Ø·ªöC KHI T·∫†O SKU
        if (!variantDto) {
          throw new BadRequestException(`‚ùå Variant ${i} is undefined`);
        }

        if (!variantDto.storage) {
          throw new BadRequestException(`‚ùå Variant ${i}: storage is required`);
        }

        if (!variantDto.color) {
          throw new BadRequestException(`‚ùå Variant ${i}: color is required`);
        }

        if (!variantDto.price || variantDto.price <= 0) {
          throw new BadRequestException(`‚ùå Variant ${i}: price must be greater than 0`);
        }

        if (variantDto.stock === undefined || variantDto.stock < 0) {
          throw new BadRequestException(`‚ùå Variant ${i}: stock must be 0 or greater`);
        }

        console.log(`‚úÖ Variant ${i} validation passed:`, {
          storage: variantDto.storage,
          color: variantDto.color,
          price: variantDto.price,
          stock: variantDto.stock
        });

        // ‚úÖ SAFE SKU GENERATION
        try {
          const productNameSafe = createProductDto.name.toString().trim().toUpperCase().replace(/\s+/g, '');
          const storageSafe = variantDto.storage.toString().trim().toUpperCase().replace(/\s+/g, '');
          const colorSafe = variantDto.color.toString().trim().toUpperCase().replace(/\s+/g, '');

          const sku = `${productNameSafe}-${storageSafe}-${colorSafe}`;

          console.log(`üè∑Ô∏è Generated SKU: ${sku}`);

          // Ki·ªÉm tra SKU ƒë√£ t·ªìn t·∫°i ch∆∞a
          const existingSku = await this.variantsRepository.findOne({
            where: { sku }
          });

          if (existingSku) {
            throw new BadRequestException(`‚ùå SKU "${sku}" ƒë√£ t·ªìn t·∫°i. Variant n√†y ƒë√£ ƒë∆∞·ª£c t·∫°o tr∆∞·ªõc ƒë√≥.`);
          }

          // üì∏ UPLOAD ·∫¢NH CHO VARIANT N·∫¶Y
          /*
           * Files structure t·ª´ frontend:
           * {
           *   'variant_0_images': [file1, file2], // ·∫¢nh cho variant ƒë·∫ßu ti√™n
           *   'variant_1_images': [file3, file4], // ·∫¢nh cho variant th·ª© hai
           *   'variant_2_images': [file5, file6]  // ·∫¢nh cho variant th·ª© ba
           * }
           */
          let variantImageUrls: string[] = [];
          let variantImagePublicIds: string[] = [];

          // L·∫•y files cho variant th·ª© i
          const variantFiles = files?.[`variant_${i}_images`];

          if (variantFiles && variantFiles.length > 0) {
            console.log(`üì∏ ƒêang upload ${variantFiles.length} ·∫£nh cho variant ${variantDto.color}`);

            // Upload t·ª´ng file l√™n Cloudinary
            for (const file of variantFiles) {
              const uploadResult = await this.cloudinaryService.uploadImage(
                file,
                `tpshop/products/${savedProduct._id}/variants/${variantDto.color}` // Folder path
              );
              variantImageUrls.push(uploadResult.secure_url);     // URL ƒë·ªÉ hi·ªÉn th·ªã
              variantImagePublicIds.push(uploadResult.public_id); // ID ƒë·ªÉ x√≥a sau n√†y
            }

            console.log(`‚úÖ ƒê√£ upload th√†nh c√¥ng ${variantImageUrls.length} ·∫£nh`);
          } else {
            console.log(`‚ÑπÔ∏è Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c upload cho variant ${variantDto.color}`);
          }

          // üíæ T·∫†O V√Ä LUU VARIANT V√ÄO DATABASE
          const variantData = {
            productId: savedProduct._id,              // Link t·ªõi s·∫£n ph·∫©m ch√≠nh
            sku,                                      // M√£ SKU unique
            storage: variantDto.storage,              // Dung l∆∞·ª£ng: "128GB"
            color: variantDto.color,                  // M√†u s·∫Øc: "ƒêen"
            price: variantDto.price,                  // Gi√°: 22000000
            stock: variantDto.stock,                  // S·ªë l∆∞·ª£ng t·ªìn: 50
            imageUrls: variantImageUrls,              // Danh s√°ch URL ·∫£nh
            imagePublicIds: variantImagePublicIds,    // Danh s√°ch Public ID
            isActive: variantDto.isActive ?? true,    // Tr·∫°ng th√°i (m·∫∑c ƒë·ªãnh true)
            sold: 0                                   // S·ªë l∆∞·ª£ng ƒë√£ b√°n (m·∫∑c ƒë·ªãnh 0)
          };

          const newVariant = this.variantsRepository.create(variantData);
          const savedVariant = await this.variantsRepository.save(newVariant);
          createdVariants.push(savedVariant);

          console.log(`‚úÖ ƒê√£ t·∫°o variant: ${savedVariant.sku} v·ªõi ${savedVariant.imageUrls.length} ·∫£nh`);
        } catch (error) {
          console.error(`‚ùå Error creating SKU for variant ${i}:`, error);
          throw new BadRequestException(`‚ùå L·ªói t·∫°o SKU cho variant ${i}: ${error.message}`);
        }
      }

      // üìä TH·ªêNG K√ä K·∫æT QU·∫¢
      const totalVariants = createdVariants.length;
      const totalStock = createdVariants.reduce((sum, variant) => sum + variant.stock, 0);
      const priceRange = {
        min: Math.min(...createdVariants.map(v => v.price)),
        max: Math.max(...createdVariants.map(v => v.price))
      };

      console.log(`üéâ HO√ÄN TH√ÄNH! S·∫£n ph·∫©m "${savedProduct.name}" ƒë√£ ƒë∆∞·ª£c t·∫°o v·ªõi:`);
      console.log(`   üì± ${totalVariants} variants`);
      console.log(`   üì¶ ${totalStock} s·∫£n ph·∫©m t·ªïng c·ªông`);
      console.log(`   üí∞ Gi√° t·ª´ ${priceRange.min.toLocaleString()}ƒë ƒë·∫øn ${priceRange.max.toLocaleString()}ƒë`);

      // Tr·∫£ v·ªÅ k·∫øt qu·∫£
      return {
        product: savedProduct,
        variants: createdVariants
      };

    } catch (error) {
      console.error('‚ùå L·ªñI KHI T·∫†O S·∫¢N PH·∫®M:', error);

      // Gi·ªØ nguy√™n l·ªói validation v√† not found
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }

      // Wrap c√°c l·ªói kh√°c
      throw new BadRequestException(`‚ùå L·ªói t·∫°o s·∫£n ph·∫©m: ${error.message}`);
    }
  }

  // ‚úÖ L·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m v·ªõi variants
  // C·∫≠p nh·∫≠t method findAll() ƒë·ªÉ tr·∫£ v·ªÅ structure ph√π h·ª£p:

  async findAll(): Promise<Product[]> {
    try {
      console.log('üìã Finding all products with variants');

      const products = await this.productsRepository.find({
        order: { createdAt: 'DESC' }
      });

      const result: Product[] = [];

      for (const product of products) {
        const variants = await this.variantsRepository.find({
          where: { productId: product._id },
          order: { price: 'ASC' } // ‚úÖ S·∫Øp x·∫øp theo gi√° tƒÉng d·∫ßn
        });

        if (variants.length > 0) {
          const productWithVariants: Product = {
            ...product,
            variants: variants.map(v => ({
              _id: v._id,
              storage: v.storage,
              color: v.color,
              price: v.price,
              stock: v.stock,
              images: v.imageUrls,
              isActive: v.isActive // ‚úÖ D√πng isActive thay v√¨ active
            }))
          } as any;

          result.push(productWithVariants);
        }
      }

      console.log(`‚úÖ Found ${result.length} products with variants`);
      return result;

    } catch (error) {
      console.error('‚ùå Error finding products:', error);
      throw new BadRequestException(`L·ªói l·∫•y danh s√°ch s·∫£n ph·∫©m: ${error.message}`);
    }
  }
// ‚úÖ TOGGLE STATUS - CH·ªà THAY ƒê·ªîI 1 VARIANT DUY NH·∫§T
async toggleVariantStatus(variantId: string): Promise<ProductVariant> {
  try {
    console.log(`üîÑ Toggling status for variant: ID=${variantId}`);

    if (!ObjectId.isValid(variantId)) {
      throw new BadRequestException(`ID variant kh√¥ng h·ª£p l·ªá: ${variantId}`);
    }

    const objectId = new ObjectId(variantId);

    // L·∫•y variant
    const variant = await this.variantsRepository.findOne({
      where: { _id: objectId }
    });

    if (!variant) {
      throw new NotFoundException(`Kh√¥ng t√¨m th·∫•y variant v·ªõi ID: ${variantId}`);
    }

    // Toggle tr·∫°ng th√°i
    const newStatus = !variant.isActive;
    variant.isActive = newStatus;
    variant.updatedAt = new Date();

    // L∆∞u l·∫°i
    const updatedVariant = await this.variantsRepository.save(variant);

    console.log(`‚úÖ Variant "${variant.sku}" toggled to: ${newStatus ? 'Active' : 'Inactive'}`);

    return updatedVariant;

  } catch (error) {
    console.error('‚ùå Error toggling variant status:', error);

    if (error instanceof BadRequestException || error instanceof NotFoundException) {
      throw error;
    }

    throw new BadRequestException(`L·ªói chuy·ªÉn ƒë·ªïi tr·∫°ng th√°i variant: ${error.message}`);
  }
}



  // ‚úÖ T√¨m theo category
  async findByCategory(categoryId: string): Promise<Array<{ product: Product; variants: ProductVariant[] }>> {
    try {
      if (!ObjectId.isValid(categoryId)) {
        throw new BadRequestException(`ID danh m·ª•c kh√¥ng h·ª£p l·ªá: ${categoryId}`);
      }

      const categoryObjectId = new ObjectId(categoryId);

      const category = await this.categoryRepository.findOne({
        where: { _id: categoryObjectId }
      });

      if (!category) {
        throw new NotFoundException(`Kh√¥ng t√¨m th·∫•y danh m·ª•c v·ªõi ID: ${categoryId}`);
      }

      const products = await this.productsRepository.find({
        where: { categoryId: categoryObjectId, isActive: true },
        order: { createdAt: 'DESC' }
      });

      const result: Array<{ product: Product; variants: ProductVariant[] }> = [];

      for (const product of products) {
        const variants = await this.variantsRepository.find({
          where: { productId: product._id, isActive: true }
        });
        if (variants.length > 0) { // Ch·ªâ tr·∫£ v·ªÅ s·∫£n ph·∫©m c√≥ variants active
          result.push({ product, variants });
        }
      }

      return result;

    } catch (error) {
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }

      throw new BadRequestException(`L·ªói t√¨m ki·∫øm s·∫£n ph·∫©m theo danh m·ª•c: ${error.message}`);
    }
  }

  // ‚úÖ T√¨m theo kho·∫£ng gi√°
  async findByPriceRange(priceRangeId: string): Promise<Array<{ product: Product; variants: ProductVariant[] }>> {
    const priceRanges: Record<string, { min: number; max: number }> = {
      'under-5m': { min: 0, max: 5000000 },
      '5m-10m': { min: 5000000, max: 10000000 },
      '10m-20m': { min: 10000000, max: 20000000 },
      '20m-30m': { min: 20000000, max: 30000000 },
      'above-30m': { min: 30000000, max: 999999999 }
    };

    const range = priceRanges[priceRangeId];
    if (!range) {
      throw new BadRequestException('Kho·∫£ng gi√° kh√¥ng h·ª£p l·ªá');
    }

    // T√¨m variants trong kho·∫£ng gi√°
    const variants = await this.variantsRepository.find({
      where: {
        price: { $gte: range.min, $lte: range.max },
        isActive: true
      }
    });

    // L·∫•y danh s√°ch unique productIds
    const productIds = [...new Set(variants.map(v => v.productId.toString()))];

    const result: Array<{ product: Product; variants: ProductVariant[] }> = [];

    for (const productIdStr of productIds) {
      const productId = new ObjectId(productIdStr);
      const product = await this.productsRepository.findOne({
        where: { _id: productId, isActive: true }
      });

      if (product) {
        const productVariants = variants.filter(v => v.productId.toString() === productIdStr);
        result.push({ product, variants: productVariants });
      }
    }

    return result;
  }

  // ‚úÖ Gi·∫£m stock cho variant c·ª• th·ªÉ (khi ƒë·∫∑t h√†ng)
  async decreaseVariantStock(variantId: string, quantity: number): Promise<void> {
    const variant = await this.variantsRepository.findOne({
      where: { _id: new ObjectId(variantId) }
    });

    if (!variant) {
      throw new BadRequestException('Bi·∫øn th·ªÉ s·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i');
    }

    if (variant.stock < quantity) {
      throw new BadRequestException(`Kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng. C√≤n l·∫°i: ${variant.stock}`);
    }

    variant.stock -= quantity;
    variant.sold += quantity;
    await this.variantsRepository.save(variant);
  }

  // ‚úÖ L·∫•y th√¥ng tin t·ªïng quan s·∫£n ph·∫©m (cho dashboard)
  async getProductStats(): Promise<{
    totalProducts: number;
    totalVariants: number;
    totalStock: number;
    totalSold: number;
  }> {
    const [products, variants] = await Promise.all([
      this.productsRepository.find(),
      this.variantsRepository.find()
    ]);

    const totalStock = variants.reduce((sum, variant) => sum + variant.stock, 0);
    const totalSold = variants.reduce((sum, variant) => sum + variant.sold, 0);

    return {
      totalProducts: products.length,
      totalVariants: variants.length,
      totalStock,
      totalSold
    };
  }

  /**
   * üîÑ C·∫¨P NH·∫¨T S·∫¢N PH·∫®M V√Ä VARIANTS
   * 
   * Ch·ª©c nƒÉng:
   * 1. Update th√¥ng tin product (name, description, category, subcategory)
   * 2. Update c√°c variants HI·ªÜN C√ì (ph·∫£i c√≥ _id)
   * 3. Upload/Update ·∫£nh cho variants
   */
 
  

  /**
   * üéØ L·∫§Y S·∫¢N PH·∫®M THEO ID (CHO FORM EDIT)
   */
  async findOne(id: string): Promise<{ product: Product; variants: ProductVariant[] }> {
    try {
      console.log('üîç Finding product by ID:', id);

      if (!ObjectId.isValid(id)) {
        throw new BadRequestException(`ID s·∫£n ph·∫©m kh√¥ng h·ª£p l·ªá: ${id}`);
      }

      const productObjectId = new ObjectId(id);

      // L·∫•y s·∫£n ph·∫©m v√† variants
      const [product, variants] = await Promise.all([
        this.productsRepository.findOne({ where: { _id: productObjectId } }),
        this.variantsRepository.find({
          where: { productId: productObjectId },
          order: { createdAt: 'ASC' }
        })
      ]);

      if (!product) {
        throw new NotFoundException(`Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m v·ªõi ID: ${id}`);
      }

      console.log(`‚úÖ Found product "${product.name}" with ${variants.length} variants`);

      return { product, variants };

    } catch (error) {
      console.error('‚ùå Error finding product:', error);

      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }

      throw new BadRequestException(`L·ªói l·∫•y th√¥ng tin s·∫£n ph·∫©m: ${error.message}`);
    }
  }

  /**
 * üÜï L·∫§Y M·ªòT VARIANT C·ª§ TH·ªÇ THEO ID
 */
async findOneVariant(variantId: string): Promise<{
  variant: ProductVariant;
  product: Product;
}> {
  try {
    console.log('üîç Finding variant by ID:', variantId);

    if (!ObjectId.isValid(variantId)) {
      throw new BadRequestException(`ID variant kh√¥ng h·ª£p l·ªá: ${variantId}`);
    }

    const variantObjectId = new ObjectId(variantId);

    // L·∫•y variant
    const variant = await this.variantsRepository.findOne({
      where: { _id: variantObjectId }
    });

    if (!variant) {
      throw new NotFoundException(`Kh√¥ng t√¨m th·∫•y variant v·ªõi ID: ${variantId}`);
    }

    // L·∫•y th√¥ng tin product
    const product = await this.productsRepository.findOne({
      where: { _id: variant.productId }
    });

    if (!product) {
      throw new NotFoundException(`Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m c·ªßa variant n√†y`);
    }

    console.log(`‚úÖ Found variant "${variant.sku}" of product "${product.name}"`);

    return { variant, product };

  } catch (error) {
    console.error('‚ùå Error finding variant:', error);

    if (error instanceof BadRequestException || error instanceof NotFoundException) {
      throw error;
    }

    throw new BadRequestException(`L·ªói l·∫•y th√¥ng tin variant: ${error.message}`);
  }
}

  // ‚úÖ L·∫•y s·∫£n ph·∫©m ƒëang sale
  async findProductsOnSale(): Promise<{ product: Product; variants: ProductVariant[] }[]> {
    // L·∫•y variants ƒëang sale
    const saleVariants = await this.variantsRepository.find({
      where: {
        isOnSale: true,
        isActive: true
      }
    });

    // Group theo productId
    const productIds = [...new Set(saleVariants.map(v => v.productId.toString()))];

    const saleProducts: { product: Product; variants: ProductVariant[] }[] = [];

    for (const productId of productIds) {
      const product = await this.productsRepository.findOne({
        where: { _id: new ObjectId(productId) }
      });

      if (product) {
        const variants = saleVariants.filter(v => v.productId.toString() === productId);
        saleProducts.push({ product, variants });
      }
    }

    return saleProducts;
  }

  // ‚úÖ √Åp d·ª•ng gi·∫£m gi√° cho variant
  async applyDiscountToVariant(variantId: string, discountPercent: number): Promise<ProductVariant> {
    try {
      console.log(`üéØ Applying ${discountPercent}% discount to variant ${variantId}`);

      // Validate input
      if (!ObjectId.isValid(variantId)) {
        throw new BadRequestException('Variant ID kh√¥ng h·ª£p l·ªá');
      }

      if (discountPercent < 0 || discountPercent > 100) {
        throw new BadRequestException('Ph·∫ßn trƒÉm gi·∫£m gi√° ph·∫£i t·ª´ 0-100');
      }

      const variant = await this.variantsRepository.findOne({
        where: { _id: new ObjectId(variantId) }
      });

      if (!variant) {
        throw new BadRequestException('Variant kh√¥ng t·ªìn t·∫°i');
      }

      // Update discount info
      variant.discountPercent = discountPercent;
      variant.isOnSale = discountPercent > 0;
      variant.updatedAt = new Date();

      const savedVariant = await this.variantsRepository.save(variant);

      console.log(`‚úÖ Applied ${discountPercent}% discount to variant ${variant.sku}`);
      console.log(`   - Original price: ${variant.price.toLocaleString('vi-VN')} VNƒê`);
      console.log(`   - Final price: ${savedVariant.finalPrice.toLocaleString('vi-VN')} VNƒê`);
      console.log(`   - Saved amount: ${savedVariant.savedAmount.toLocaleString('vi-VN')} VNƒê`);

      return savedVariant;

    } catch (error) {
      console.error('‚ùå Error applying discount to variant:', error);

      if (error instanceof BadRequestException) {
        throw error;
      }

      throw new BadRequestException(`L·ªói √°p d·ª•ng gi·∫£m gi√°: ${error.message}`);
    }
  }

  // ‚úÖ B·ªè gi·∫£m gi√° cho variant
  async removeDiscountFromVariant(variantId: string): Promise<ProductVariant> {
    try {
      console.log(`üîÑ Removing discount from variant ${variantId}`);

      if (!ObjectId.isValid(variantId)) {
        throw new BadRequestException('Variant ID kh√¥ng h·ª£p l·ªá');
      }

      const variant = await this.variantsRepository.findOne({
        where: { _id: new ObjectId(variantId) }
      });

      if (!variant) {
        throw new BadRequestException('Variant kh√¥ng t·ªìn t·∫°i');
      }

      // Reset discount
      variant.discountPercent = 0;
      variant.isOnSale = false;
      variant.updatedAt = new Date();

      const savedVariant = await this.variantsRepository.save(variant);

      console.log(`‚úÖ Removed discount from variant ${variant.sku}`);
      console.log(`   - Price back to: ${variant.price.toLocaleString('vi-VN')} VNƒê`);

      return savedVariant;

    } catch (error) {
      console.error('‚ùå Error removing discount from variant:', error);

      if (error instanceof BadRequestException) {
        throw error;
      }

      throw new BadRequestException(`L·ªói b·ªè gi·∫£m gi√°: ${error.message}`);
    }
  }

  // ‚úÖ √Åp d·ª•ng gi·∫£m gi√° cho t·∫•t c·∫£ variants c·ªßa 1 product
  async applyDiscountToProduct(productId: string, discountPercent: number): Promise<ProductVariant[]> {
    try {
      console.log(`üéØ Applying ${discountPercent}% discount to ALL variants of product ${productId}`);

      // Validate input
      if (!ObjectId.isValid(productId)) {
        throw new BadRequestException('Product ID kh√¥ng h·ª£p l·ªá');
      }

      if (discountPercent < 0 || discountPercent > 100) {
        throw new BadRequestException('Ph·∫ßn trƒÉm gi·∫£m gi√° ph·∫£i t·ª´ 0-100');
      }

      // Get all variants of the product
      const variants = await this.variantsRepository.find({
        where: { productId: new ObjectId(productId) }
      });

      if (variants.length === 0) {
        throw new BadRequestException('Product kh√¥ng c√≥ variant n√†o');
      }

      console.log(`üì¶ Found ${variants.length} variants to update`);

      // Update all variants
      const updatedVariants: ProductVariant[] = [];

      for (const variant of variants) {
        variant.discountPercent = discountPercent;
        variant.isOnSale = discountPercent > 0;
        variant.updatedAt = new Date();

        const savedVariant = await this.variantsRepository.save(variant);
        updatedVariants.push(savedVariant);

        console.log(`   ‚úÖ Updated variant ${variant.sku}: ${variant.price.toLocaleString('vi-VN')} ‚Üí ${savedVariant.finalPrice.toLocaleString('vi-VN')} VNƒê`);
      }

      console.log(`üéâ Applied ${discountPercent}% discount to ${updatedVariants.length} variants`);

      return updatedVariants;

    } catch (error) {
      console.error('‚ùå Error applying discount to product:', error);

      if (error instanceof BadRequestException) {
        throw error;
      }

      throw new BadRequestException(`L·ªói √°p d·ª•ng gi·∫£m gi√° cho s·∫£n ph·∫©m: ${error.message}`);
    }
  }

  // ‚úÖ L·∫•y danh s√°ch variants ƒëang sale
  async getVariantsOnSale(): Promise<ProductVariant[]> {
    try {
      console.log('üìã Getting all variants on sale');

      const saleVariants = await this.variantsRepository.find({
        where: {
          isOnSale: true,
          isActive: true
        },
        order: { discountPercent: 'DESC' } // S·∫Øp x·∫øp theo % gi·∫£m gi√° gi·∫£m d·∫ßn
      });

      console.log(`‚úÖ Found ${saleVariants.length} variants on sale`);

      return saleVariants;

    } catch (error) {
      console.error('‚ùå Error getting sale variants:', error);
      throw new BadRequestException(`L·ªói l·∫•y danh s√°ch variants sale: ${error.message}`);
    }
  }

  // ‚úÖ L·∫•y th·ªëng k√™ gi·∫£m gi√°
  async getDiscountStats(): Promise<{
    totalVariantsOnSale: number;
    averageDiscountPercent: number;
    totalSavingsAmount: number;
    topDiscountVariants: Array<{
      sku: string;
      productName: string;
      originalPrice: number;
      finalPrice: number;
      discountPercent: number;
      savedAmount: number;
    }>;
  }> {
    try {
      console.log('üìä Getting discount statistics');

      const saleVariants = await this.variantsRepository.find({
        where: {
          isOnSale: true,
          isActive: true
        }
      });

      if (saleVariants.length === 0) {
        return {
          totalVariantsOnSale: 0,
          averageDiscountPercent: 0,
          totalSavingsAmount: 0,
          topDiscountVariants: []
        };
      }

      // Calculate statistics
      const totalVariantsOnSale = saleVariants.length;
      const averageDiscountPercent = saleVariants.reduce((sum, v) => sum + v.discountPercent, 0) / totalVariantsOnSale;
      const totalSavingsAmount = saleVariants.reduce((sum, v) => sum + v.savedAmount, 0);

      // Get top discount variants (top 5)
      const topDiscountVariants = saleVariants
        .sort((a, b) => b.discountPercent - a.discountPercent)
        .slice(0, 5)
        .map(variant => ({
          sku: variant.sku,
          productName: `${variant.storage} - ${variant.color}`, // Temporary, should get product name
          originalPrice: variant.price,
          finalPrice: variant.finalPrice,
          discountPercent: variant.discountPercent,
          savedAmount: variant.savedAmount
        }));

      console.log(`üìä Discount Stats:`, {
        totalVariantsOnSale,
        averageDiscountPercent: Math.round(averageDiscountPercent * 100) / 100,
        totalSavingsAmount: totalSavingsAmount.toLocaleString('vi-VN')
      });

      return {
        totalVariantsOnSale,
        averageDiscountPercent: Math.round(averageDiscountPercent * 100) / 100,
        totalSavingsAmount,
        topDiscountVariants
      };

    } catch (error) {
      console.error('‚ùå Error getting discount stats:', error);
      throw new BadRequestException(`L·ªói l·∫•y th·ªëng k√™ gi·∫£m gi√°: ${error.message}`);
    }
  }

  /**
   * üîç SEMANTIC SEARCH USING VECTOR SIMILARITY
   * ‚ùå COMMENT V√å QUOTA GEMINI H·∫æT
   */
  // async searchByVector(searchQuery: string): Promise<{
  //   products: Array<{
  //     product: Product;
  //     variants: ProductVariant[];
  //     similarity: number;
  //   }>;
  //   searchQuery: string;
  //   totalFound: number;
  // }> {
  //   try {
  //     console.log(`üîç Searching for: "${searchQuery}"`);

  //     // STEP 1: Create vector for search query
  //     console.log('üß† Creating embedding for search query...');
  //     const searchVector = await this.geminiService.createEmbedding(searchQuery);
  //     console.log(`‚úÖ Search vector has ${searchVector.length} dimensions`);

  //     // STEP 2: Get all products with embeddings
  //     console.log('üìä Getting all products with embeddings...');
  //     const allProducts = await this.productsRepository.find({
  //       where: {
  //         isActive: true,
  //         embedding: { $exists: true, $ne: [] }
  //       }
  //     });
  //     console.log(`üì¶ Found ${allProducts.length} products with embeddings`);

  //     // STEP 3: Calculate similarity for each product
  //     console.log('üî¢ Calculating similarities...');
  //     const similarityResults: Array<{
  //       product: Product;
  //       similarity: number;
  //     }> = [];

  //     for (const product of allProducts) {
  //       if (!product.embedding || product.embedding.length === 0) {
  //         console.log(`‚ö†Ô∏è Product "${product.name}" has no embedding, skipping`);
  //         continue;
  //       }

  //       // Calculate similarity
  //       const similarity = this.geminiService.calculateSimilarity(
  //         searchVector,
  //         product.embedding
  //       );

  //       // Only include products with similarity >= 0.3 (30%)
  //       if (similarity >= 0.3) {
  //         similarityResults.push({
  //           product: product,
  //           similarity: similarity
  //         });
  //       }
  //     }

  //     console.log(`üéØ Found ${similarityResults.length} relevant products`);

  //     // STEP 4: Sort by similarity (highest first)
  //     similarityResults.sort((a, b) => b.similarity - a.similarity);

  //     // STEP 5: Take top 10 results
  //     const topResults = similarityResults.slice(0, 10);

  //     // STEP 6: Get variants for each product
  //     const finalResults: Array<{
  //       product: Product;
  //       variants: ProductVariant[];
  //       similarity: number;
  //     }> = [];

  //     for (const item of topResults) {
  //       const variants = await this.variantsRepository.find({
  //         where: { productId: item.product._id, isActive: true },
  //         order: { price: 'ASC' }
  //       });

  //       if (variants.length > 0) {
  //         finalResults.push({
  //           product: item.product,
  //           variants: variants,
  //           similarity: item.similarity
  //         });
  //       }
  //     }

  //     console.log(`‚úÖ Returning ${finalResults.length} products`);

  //     return {
  //       products: finalResults,
  //       searchQuery: searchQuery,
  //       totalFound: finalResults.length
  //     };

  //   } catch (error) {
  //     console.error('‚ùå Search error:', error);
  //     throw new Error(`Search failed: ${error.message}`);
  //   }
  // }

  /**
   * üîÑ UPDATE CH·ªà M·ªòT VARIANT C·ª§ TH·ªÇ
   * 
   * @description Update th√¥ng tin c·ªßa 1 variant duy nh·∫•t (storage, color, price, stock, isActive)
   * @param variantId - ID c·ªßa variant c·∫ßn update
   * @param updateData - D·ªØ li·ªáu m·ªõi ƒë·ªÉ update
   * @param files - File ·∫£nh m·ªõi (optional)
   * @returns Promise<ProductVariant> - Variant ƒë√£ ƒë∆∞·ª£c update
   * 
   * @example
   * // Update gi√° v√† s·ªë l∆∞·ª£ng
   * await updateVariant('variant_id_123', {
   *   price: 25000000,
   *   stock: 100
   * });
   * 
   * // Update gi√° + gi·∫£m gi√°
   * await updateVariant('variant_id_123', {
   *   price: 25000000,
   *   discountPercent: 20  // Gi·∫£m 20%
   * });
   * 
   * // Update c·∫£ ·∫£nh
   * await updateVariant('variant_id_123', { price: 25000000 }, files);
   */
  async updateVariant(
    variantId: string,
    updateData: {
      storage?: string;
      color?: string;
      price?: number;
      stock?: number;
      discountPercent?: number;
      isActive?: boolean;
    },
    files?: Express.Multer.File[]
  ): Promise<ProductVariant> {
    try {
      console.log('üîÑ Updating single variant:', variantId);
      console.log('üìù Update data:', updateData);

      // ===== B∆Ø·ªöC 1: VALIDATE VARIANT ID =====
      // Ki·ªÉm tra xem variantId c√≥ ƒë√∫ng ƒë·ªãnh d·∫°ng ObjectId kh√¥ng
      if (!ObjectId.isValid(variantId)) {
        throw new BadRequestException(`‚ùå ID variant kh√¥ng h·ª£p l·ªá: ${variantId}`);
      }

      const variantObjectId = new ObjectId(variantId);

      // ===== B∆Ø·ªöC 2: T√åM VARIANT TRONG DATABASE =====
      // T√¨m variant hi·ªán t·∫°i t·ª´ database
      const existingVariant = await this.variantsRepository.findOne({
        where: { _id: variantObjectId }
      });

      // N·∫øu kh√¥ng t√¨m th·∫•y ‚Üí n√©m l·ªói 404
      if (!existingVariant) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y variant v·ªõi ID: ${variantId}`);
      }

      console.log(`‚úÖ Found variant: ${existingVariant.sku}`);

      // ===== B∆Ø·ªöC 3: L·∫§Y TH√îNG TIN PRODUCT (ƒê·ªÇ T·∫†O SKU M·ªöI) =====
      // C·∫ßn product name ƒë·ªÉ t·∫°o SKU n·∫øu storage/color thay ƒë·ªïi
      const product = await this.productsRepository.findOne({
        where: { _id: existingVariant.productId }
      });

      if (!product) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m c·ªßa variant n√†y`);
      }

      console.log(`‚úÖ Product: "${product.name}"`);

      // ===== B∆Ø·ªöC 4: UPDATE C√ÅC TR∆Ø·ªúNG TH√îNG TIN =====
      
      // üì¶ Update STORAGE (n·∫øu c√≥)
      if (updateData.storage !== undefined) {
        // Validate: kh√¥ng ƒë∆∞·ª£c r·ªóng
        if (!updateData.storage.trim()) {
          throw new BadRequestException('‚ùå Dung l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
        }
        
        console.log(`üì¶ Updating storage: "${existingVariant.storage}" ‚Üí "${updateData.storage}"`);
        existingVariant.storage = updateData.storage.trim();
      }

      // üé® Update COLOR (n·∫øu c√≥)
      if (updateData.color !== undefined) {
        // Validate: kh√¥ng ƒë∆∞·ª£c r·ªóng
        if (!updateData.color.trim()) {
          throw new BadRequestException('‚ùå M√†u s·∫Øc kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
        }
        
        console.log(`üé® Updating color: "${existingVariant.color}" ‚Üí "${updateData.color}"`);
        existingVariant.color = updateData.color.trim();
      }

      // üí∞ Update PRICE (n·∫øu c√≥)
      if (updateData.price !== undefined) {
        // Validate: ph·∫£i > 0
        if (updateData.price <= 0) {
          throw new BadRequestException('‚ùå Gi√° ph·∫£i l·ªõn h∆°n 0');
        }
        
        // Validate: kh√¥ng qu√° 1 t·ª∑
        if (updateData.price > 1_000_000_000) {
          throw new BadRequestException('‚ùå Gi√° kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 1 t·ª∑ VNƒê');
        }
        
        console.log(`üí∞ Updating price: ${existingVariant.price.toLocaleString('vi-VN')} ‚Üí ${updateData.price.toLocaleString('vi-VN')} VNƒê`);
        existingVariant.price = updateData.price;
      }

      // üì¶ Update STOCK (n·∫øu c√≥)
      if (updateData.stock !== undefined) {
        // Validate: kh√¥ng ƒë∆∞·ª£c √¢m
        if (updateData.stock < 0) {
          throw new BadRequestException('‚ùå S·ªë l∆∞·ª£ng kh√¥ng ƒë∆∞·ª£c √¢m');
        }
        
        console.log(`üì¶ Updating stock: ${existingVariant.stock} ‚Üí ${updateData.stock}`);
        existingVariant.stock = updateData.stock;
      }

      // üè∑Ô∏è Update DISCOUNT (n·∫øu c√≥)
      if (updateData.discountPercent !== undefined) {
        // Validate: ph·∫£i t·ª´ 0-100
        if (updateData.discountPercent < 0 || updateData.discountPercent > 100) {
          throw new BadRequestException('‚ùå Gi·∫£m gi√° ph·∫£i t·ª´ 0-100%');
        }
        
        console.log(`üè∑Ô∏è Updating discount: ${existingVariant.discountPercent}% ‚Üí ${updateData.discountPercent}%`);
        existingVariant.discountPercent = updateData.discountPercent;
        existingVariant.isOnSale = updateData.discountPercent > 0;
        
        // ‚úÖ T·ª± ƒë·ªông t√≠nh finalPrice v√† savedAmount (t·ª´ @BeforeInsert/@BeforeUpdate)
      }

      // ‚úÖ Update IS_ACTIVE (n·∫øu c√≥)
      if (updateData.isActive !== undefined) {
        console.log(`‚úÖ Updating isActive: ${existingVariant.isActive} ‚Üí ${updateData.isActive}`);
        existingVariant.isActive = updateData.isActive;
      }

      // ===== B∆Ø·ªöC 5: UPDATE SKU (N·∫æU STORAGE HO·∫∂C COLOR THAY ƒê·ªîI) =====
      /**
       * SKU Format: PRODUCTNAME-STORAGE-COLOR
       * Example: IPHONE16-256GB-VIOLET
       * 
       * Ch·ªâ update SKU khi:
       * - Storage ho·∫∑c Color thay ƒë·ªïi
       * - SKU m·ªõi ph·∫£i unique (kh√¥ng tr√πng variant kh√°c)
       */
      const newSku = `${product.name.toUpperCase().replace(/\s+/g, '')}-${existingVariant.storage.toUpperCase().replace(/\s+/g, '')}-${existingVariant.color.toUpperCase().replace(/\s+/g, '')}`;
      
      // N·∫øu SKU thay ƒë·ªïi ‚Üí validate uniqueness
      if (newSku !== existingVariant.sku) {
        console.log(`üè∑Ô∏è SKU changed: "${existingVariant.sku}" ‚Üí "${newSku}"`);
        
        // Ki·ªÉm tra SKU m·ªõi ƒë√£ t·ªìn t·∫°i ch∆∞a
        const duplicateSku = await this.variantsRepository.findOne({
          where: { 
            sku: newSku,
            _id: { $ne: variantObjectId } // Lo·∫°i tr·ª´ ch√≠nh variant n√†y
          }
        });

        if (duplicateSku) {
          throw new BadRequestException(
            `‚ùå SKU "${newSku}" ƒë√£ t·ªìn t·∫°i cho variant kh√°c. ` +
            `Vui l√≤ng ch·ªçn storage/color kh√°c ho·∫∑c ki·ªÉm tra l·∫°i.`
          );
        }

        existingVariant.sku = newSku;
        console.log(`‚úÖ SKU updated successfully`);
      } else {
        console.log(`‚ÑπÔ∏è SKU unchanged: "${existingVariant.sku}"`);
      }

      // ===== B∆Ø·ªöC 6: UPDATE IMAGES (N·∫æU C√ì FILE M·ªöI) =====
      /**
       * Quy tr√¨nh:
       * 1. X√≥a T·∫§T C·∫¢ ·∫£nh c≈© tr√™n Cloudinary
       * 2. Upload ·∫£nh m·ªõi l√™n Cloudinary
       * 3. L∆∞u URLs v√† publicIds m·ªõi
       */
      if (files && files.length > 0) {
        console.log(`üì∏ Updating ${files.length} images for variant ${existingVariant.color}`);

        // STEP 6.1: X√ìA ·∫¢NH C≈® TR√äN CLOUDINARY
        if (existingVariant.imagePublicIds && existingVariant.imagePublicIds.length > 0) {
          console.log(`üóëÔ∏è Deleting ${existingVariant.imagePublicIds.length} old images...`);
          
          for (const publicId of existingVariant.imagePublicIds) {
            try {
              await this.cloudinaryService.deleteImage(publicId);
              console.log(`   ‚úÖ Deleted: ${publicId}`);
            } catch (error) {
              // Kh√¥ng n√©m l·ªói n·∫øu x√≥a th·∫•t b·∫°i, ch·ªâ log warning
              console.warn(`   ‚ö†Ô∏è Failed to delete ${publicId}: ${error.message}`);
            }
          }
        }

        // STEP 6.2: UPLOAD ·∫¢NH M·ªöI L√äN CLOUDINARY
        console.log('üì§ Uploading new images...');
        const newImageUrls: string[] = [];
        const newImagePublicIds: string[] = [];

        for (let i = 0; i < files.length; i++) {
          const file = files[i];
          console.log(`   üì∏ Uploading image ${i + 1}/${files.length}...`);
          
          try {
            // Upload v·ªõi folder path: tpshop/products/{productId}/variants/{color}
            const result = await this.cloudinaryService.uploadImage(
              file,
              `tpshop/products/${product._id}/variants/${existingVariant.color}`
            );
            
            newImageUrls.push(result.secure_url);
            newImagePublicIds.push(result.public_id);
            
            console.log(`   ‚úÖ Uploaded: ${result.public_id}`);
          } catch (error) {
            console.error(`   ‚ùå Failed to upload image ${i + 1}:`, error.message);
            throw new BadRequestException(`‚ùå L·ªói upload ·∫£nh ${i + 1}: ${error.message}`);
          }
        }

        // STEP 6.3: C·∫¨P NH·∫¨T URLS V√Ä PUBLIC_IDS
        existingVariant.imageUrls = newImageUrls;
        existingVariant.imagePublicIds = newImagePublicIds;
        
        console.log(`‚úÖ Updated images: ${newImageUrls.length} new images saved`);
      } else {
        console.log('‚ÑπÔ∏è No new images to update');
      }

      // ===== B∆Ø·ªöC 7: C·∫¨P NH·∫¨T TIMESTAMP V√Ä L∆ØU V√ÄO DATABASE =====
      existingVariant.updatedAt = new Date();
      
      console.log('üíæ Saving variant to database...');
      const savedVariant = await this.variantsRepository.save(existingVariant);
      
      console.log(`‚úÖ Variant updated successfully!`);
      console.log(`üìä Final data:`, {
        sku: savedVariant.sku,
        storage: savedVariant.storage,
        color: savedVariant.color,
        price: savedVariant.price.toLocaleString('vi-VN'),
        stock: savedVariant.stock,
        discountPercent: savedVariant.discountPercent,
        finalPrice: savedVariant.finalPrice?.toLocaleString('vi-VN'),
        isActive: savedVariant.isActive,
        imageCount: savedVariant.imageUrls.length
      });

      return savedVariant;

    } catch (error) {
      console.error('‚ùå Error updating variant:', error);

      // Gi·ªØ nguy√™n l·ªói validation
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }

      // Wrap c√°c l·ªói kh√°c
      throw new BadRequestException(`‚ùå L·ªói c·∫≠p nh·∫≠t variant: ${error.message}`);
    }
  }

  /**
   * üóëÔ∏è X√ìA CH·ªà M·ªòT VARIANT C·ª§ TH·ªÇ
   * 
   * @description X√≥a 1 variant duy nh·∫•t m√† kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn:
   * - Product ch√≠nh
   * - C√°c variants kh√°c
   * 
   * @param variantId - ID c·ªßa variant c·∫ßn x√≥a
   * @returns Promise<{ message, deletedVariant, deletedImagesCount }>
   * 
   * @throws {BadRequestException} N·∫øu variantId kh√¥ng h·ª£p l·ªá
   * @throws {NotFoundException} N·∫øu variant kh√¥ng t·ªìn t·∫°i
   * @throws {BadRequestException} N·∫øu ƒë√¢y l√† variant cu·ªëi c√πng c·ªßa product
   * 
   * @example
   * await productsService.deleteVariant('variant_id_123');
   */
  async deleteVariant(variantId: string): Promise<{
    message: string;
    deletedVariant: {
      sku: string;
      storage: string;
      color: string;
    };
    deletedImagesCount: number;
    productName: string;
    remainingVariants: number;
  }> {
    try {
      console.log(`üóëÔ∏è Deleting variant: ID=${variantId}`);

      // ===== B∆Ø·ªöC 1: VALIDATE VARIANT ID =====
      if (!ObjectId.isValid(variantId)) {
        throw new BadRequestException(`‚ùå ID variant kh√¥ng h·ª£p l·ªá: ${variantId}`);
      }

      const variantObjectId = new ObjectId(variantId);

      // ===== B∆Ø·ªöC 2: T√åM VARIANT TRONG DATABASE =====
      const existingVariant = await this.variantsRepository.findOne({
        where: { _id: variantObjectId }
      });

      if (!existingVariant) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y variant v·ªõi ID: ${variantId}`);
      }

      console.log(`‚úÖ Found variant: ${existingVariant.sku}`);

      // ===== B∆Ø·ªöC 3: KI·ªÇM TRA ƒê√ÇY C√ì PH·∫¢I VARIANT CU·ªêI C√ôNG KH√îNG =====
      /**
       * Kh√¥ng cho ph√©p x√≥a variant cu·ªëi c√πng v√¨:
       * - Product ph·∫£i c√≥ √≠t nh·∫•t 1 variant
       * - N·∫øu mu·ªën x√≥a h·∫øt ‚Üí x√≥a lu√¥n c·∫£ product
       */
      const totalVariants = await this.variantsRepository.count({
        where: { productId: existingVariant.productId }
      });

      if (totalVariants === 1) {
        throw new BadRequestException(
          `‚ùå Kh√¥ng th·ªÉ x√≥a variant cu·ªëi c√πng!\n` +
          `S·∫£n ph·∫©m ph·∫£i c√≥ √≠t nh·∫•t 1 variant.\n` +
          `N·∫øu mu·ªën x√≥a to√†n b·ªô, vui l√≤ng x√≥a s·∫£n ph·∫©m ch√≠nh.`
        );
      }

      console.log(`‚ÑπÔ∏è Product has ${totalVariants} variants (${totalVariants - 1} will remain after deletion)`);

      // ===== B∆Ø·ªöC 4: L·∫§Y TH√îNG TIN PRODUCT (ƒê·ªÇ HI·ªÇN TH·ªä MESSAGE) =====
      const product = await this.productsRepository.findOne({
        where: { _id: existingVariant.productId }
      });

      if (!product) {
        throw new NotFoundException(`‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m c·ªßa variant n√†y`);
      }

      console.log(`‚úÖ Product: "${product.name}"`);

      // ===== B∆Ø·ªöC 5: X√ìA T·∫§T C·∫¢ ·∫¢NH TR√äN CLOUDINARY =====
      let deletedImagesCount = 0;

      if (existingVariant.imagePublicIds && existingVariant.imagePublicIds.length > 0) {
        console.log(`üñºÔ∏è Deleting ${existingVariant.imagePublicIds.length} images from Cloudinary...`);

        for (const publicId of existingVariant.imagePublicIds) {
          try {
            await this.cloudinaryService.deleteImage(publicId);
            deletedImagesCount++;
            console.log(`   ‚úÖ Deleted: ${publicId}`);
          } catch (error) {
            // Kh√¥ng n√©m l·ªói n·∫øu x√≥a ·∫£nh th·∫•t b·∫°i
            console.warn(`   ‚ö†Ô∏è Failed to delete ${publicId}: ${error.message}`);
          }
        }

        console.log(`‚úÖ Deleted ${deletedImagesCount}/${existingVariant.imagePublicIds.length} images`);
      } else {
        console.log(`‚ÑπÔ∏è No images to delete`);
      }

      // ===== B∆Ø·ªöC 6: X√ìA VARIANT KH·ªéI DATABASE =====
      await this.variantsRepository.delete({ _id: variantObjectId });

      console.log(`‚úÖ Deleted variant "${existingVariant.sku}" from database`);

      // ===== B∆Ø·ªöC 7: TR·∫¢ V·ªÄ K·∫æT QU·∫¢ =====
      const remainingVariants = totalVariants - 1;

      return {
        message: `ƒê√£ x√≥a variant "${existingVariant.storage} - ${existingVariant.color}" kh·ªèi s·∫£n ph·∫©m "${product.name}"`,
        deletedVariant: {
          sku: existingVariant.sku,
          storage: existingVariant.storage,
          color: existingVariant.color
        },
        deletedImagesCount: deletedImagesCount,
        productName: product.name,
        remainingVariants: remainingVariants
      };

    } catch (error) {
      console.error('‚ùå Error deleting variant:', error);

      // Gi·ªØ nguy√™n l·ªói validation
      if (error instanceof BadRequestException || error instanceof NotFoundException) {
        throw error;
      }

      // Wrap c√°c l·ªói kh√°c
      throw new BadRequestException(`‚ùå L·ªói x√≥a variant: ${error.message}`);
    }
  }
}
